---
alwaysApply: true
---

# 設計原則ガイド

## 🎯 核となる設計原則

### 1. YAGNI (You Aren't Gonna Need It)
**今必要でない機能は実装しない**

```ruby
# ❌ 悪い例：将来使うかもしれない機能を先に実装
class RBSParser
  def parse_file(file_path)
    # 基本的な解析
  end
  
  def parse_with_cache(file_path)  # まだ使わない機能
    # キャッシュ機能
  end
  
  def parse_with_validation(file_path)  # まだ使わない機能
    # バリデーション機能
  end
end

# ✅ 良い例：必要な機能のみ実装
class RBSParser
  def parse_file(file_path)
    # 基本的な解析のみ
  end
  
  # キャッシュやバリデーションは必要になった時に追加
end
```

**効果**: コードがシンプルになり、開発速度が上がる

### 2. 単一責務原則
**1つのクラスは1つの責務のみを持つ**

```ruby
# ❌ 悪い例：複数の責務を持つクラス
class RBSProcessor
  def parse_file(file_path)
    # ファイル解析
  end
  
  def generate_mermaid(data)
    # Mermaid生成
  end
  
  def save_to_file(content, path)
    # ファイル保存
  end
end

# ✅ 良い例：責務を分離
class RBSParser
  def parse_file(file_path)
    # ファイル解析のみ
  end
end

class DiagramFormatter
  def generate_mermaid(data)
    # Mermaid生成のみ
  end
end
```

**効果**: 変更の影響範囲が限定され、テストが容易になる

### 3. コードの簡潔さ
**必要最小限のコードで表現する**

```ruby
# ❌ 悪い例：不要な複雑さ
class ClassDefinition
  def initialize(name, methods)
    @class_name = name  # 説明的すぎる変数名
    @method_list = methods
    @is_valid = true  # 使われない変数
  end
  
  # 翻訳コメント（不要）
  def get_class_name  # 冗長なメソッド名
    return @class_name
  end
end

# ✅ 良い例：簡潔で明確
class ClassDefinition
  attr_reader :name, :methods
  
  def initialize(name, methods)
    @name = name
    @methods = methods
  end
end
```

**効果**: 可読性が向上し、メンテナンスが容易になる

## 📝 実装時の判断基準

### 機能追加の判断
1. **今すぐ必要か？** → Yes なら実装、No なら見送り
2. **責務は明確か？** → 複数の責務があれば分離を検討
3. **シンプルに書けるか？** → 複雑になりそうなら設計を見直し

### コメントの判断
```ruby
# ❌ 悪い例：翻訳コメント
def parse_rbs_file(path)
  # RBSファイルを解析する
  content = File.read(path)
end

# ✅ 良い例：意図を説明
def parse_rbs_file(path)
  # RBSライブラリの制約により、事前にエンコーディングを統一
  content = File.read(path, encoding: 'UTF-8')
end
```

### 重複の判断
```ruby
# ❌ 悪い例：同じ情報を複数箇所で定義
class ClassDefinition
  SUPPORTED_TYPES = ['String', 'Integer', 'Array']
end

class ModuleDefinition  
  SUPPORTED_TYPES = ['String', 'Integer', 'Array']  # 重複
end

# ✅ 良い例：1箇所で定義して共有
module TypeConstants
  SUPPORTED_TYPES = ['String', 'Integer', 'Array']
end

class ClassDefinition
  include TypeConstants
end
```

## 🔧 Kiroの作業指針

### 設計時
1. **最小限の機能から始める** - YAGNIを意識
2. **責務を明確にする** - 1クラス1責務
3. **シンプルに保つ** - 複雑さを避ける

### 実装時
1. **必要な機能のみ実装**
2. **明確な命名を使用**
3. **不要なコメントは書かない**

### レビュー時
1. **本当に必要な機能か確認**
2. **責務が分離されているか確認**
3. **コードが自己説明的か確認**# 設計原則ガイド

## 🎯 核となる設計原則

### 1. YAGNI (You Aren't Gonna Need It)
**今必要でない機能は実装しない**

```ruby
# ❌ 悪い例：将来使うかもしれない機能を先に実装
class RBSParser
  def parse_file(file_path)
    # 基本的な解析
  end
  
  def parse_with_cache(file_path)  # まだ使わない機能
    # キャッシュ機能
  end
  
  def parse_with_validation(file_path)  # まだ使わない機能
    # バリデーション機能
  end
end

# ✅ 良い例：必要な機能のみ実装
class RBSParser
  def parse_file(file_path)
    # 基本的な解析のみ
  end
  
  # キャッシュやバリデーションは必要になった時に追加
end
```

**効果**: コードがシンプルになり、開発速度が上がる

### 2. 単一責務原則
**1つのクラスは1つの責務のみを持つ**

```ruby
# ❌ 悪い例：複数の責務を持つクラス
class RBSProcessor
  def parse_file(file_path)
    # ファイル解析
  end
  
  def generate_mermaid(data)
    # Mermaid生成
  end
  
  def save_to_file(content, path)
    # ファイル保存
  end
end

# ✅ 良い例：責務を分離
class RBSParser
  def parse_file(file_path)
    # ファイル解析のみ
  end
end

class DiagramFormatter
  def generate_mermaid(data)
    # Mermaid生成のみ
  end
end
```

**効果**: 変更の影響範囲が限定され、テストが容易になる

### 3. コードの簡潔さ
**必要最小限のコードで表現する**

```ruby
# ❌ 悪い例：不要な複雑さ
class ClassDefinition
  def initialize(name, methods)
    @class_name = name  # 説明的すぎる変数名
    @method_list = methods
    @is_valid = true  # 使われない変数
  end
  
  # 翻訳コメント（不要）
  def get_class_name  # 冗長なメソッド名
    return @class_name
  end
end

# ✅ 良い例：簡潔で明確
class ClassDefinition
  attr_reader :name, :methods
  
  def initialize(name, methods)
    @name = name
    @methods = methods
  end
end
```

**効果**: 可読性が向上し、メンテナンスが容易になる

## 📝 実装時の判断基準

### 機能追加の判断
1. **今すぐ必要か？** → Yes なら実装、No なら見送り
2. **責務は明確か？** → 複数の責務があれば分離を検討
3. **シンプルに書けるか？** → 複雑になりそうなら設計を見直し

### コメントの判断
```ruby
# ❌ 悪い例：翻訳コメント
def parse_rbs_file(path)
  # RBSファイルを解析する
  content = File.read(path)
end

# ✅ 良い例：意図を説明
def parse_rbs_file(path)
  # RBSライブラリの制約により、事前にエンコーディングを統一
  content = File.read(path, encoding: 'UTF-8')
end
```

### 重複の判断
```ruby
# ❌ 悪い例：同じ情報を複数箇所で定義
class ClassDefinition
  SUPPORTED_TYPES = ['String', 'Integer', 'Array']
end

class ModuleDefinition  
  SUPPORTED_TYPES = ['String', 'Integer', 'Array']  # 重複
end

# ✅ 良い例：1箇所で定義して共有
module TypeConstants
  SUPPORTED_TYPES = ['String', 'Integer', 'Array']
end

class ClassDefinition
  include TypeConstants
end
```

## 🔧 Kiroの作業指針

### 設計時
1. **最小限の機能から始める** - YAGNIを意識
2. **責務を明確にする** - 1クラス1責務
3. **シンプルに保つ** - 複雑さを避ける

### 実装時
1. **必要な機能のみ実装**
2. **明確な命名を使用**
3. **不要なコメントは書かない**

### レビュー時
1. **本当に必要な機能か確認**
2. **責務が分離されているか確認**
3. **コードが自己説明的か確認**