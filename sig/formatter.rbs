
interface _FormatterResultMethod
  def name: () -> String
  def method_type: () -> String
  def visibility: () -> String
  def return_type: () -> String
  def parameters: () -> Array[Parameter]
  def overloads: () -> Array[Hash[Symbol, untyped]]
  def block: () -> Result::NodeEntity::Block?
  def respond_to?: (Symbol | String) -> bool
  def to_s: () -> String
  def to_visibility_str: () -> String
  def to_static_str: (?Symbol format_type) -> String
  def to_params_str: () -> String
  def to_block_str: () -> String
  def to_return_type_str: (?Symbol format_type) -> String
end


interface _Node
  def name: () -> String
  def type: () -> Symbol
  def is_a?: (Module) -> bool
  def is_namespace: () -> bool
  def methods_ordered_by_visibility_and_type: () -> Array[_FormatterResultMethod]
  def methods: () -> Array[_FormatterResultMethod]
  def relationships: () -> Array[Result::NodeEntity::Relationship]
  def includes: () -> Array[String]
  def extends: () -> Array[String]
  def respond_to?: (Symbol) -> bool
end

interface _ClassNode
  include _Node
  def superclass: () -> String?
  def inner_classes: () -> Array[Hash[Symbol, untyped]]
end

module Formatter
  class Diagram
    class Indentation
      @level: Integer
      @width: Integer
      @char: String
      @has_namespaces: bool

      def initialize: (?level: Integer, ?width: Integer, ?char: String, ?has_namespaces: bool) -> void
      def increase: () -> void
      def decrease: () -> void
      def reset: () -> void
      def to_s: () -> String
      def current_level: () -> Integer
      def set_namespaces: (bool flag) -> void
      def with_increased_level: () { (Indentation) -> void } -> void
      def copy: () -> Indentation

      private

      attr_reader level: Integer
      attr_reader width: Integer
      attr_reader char: String
      attr_reader has_namespaces: bool
    end
    module DiagramDetail
      interface _EntityBuilder
        def build_entities: () -> Hash[Symbol, Array[untyped]]
      end
      
      interface _NamespaceCollection
        def collect_namespaces_with_classes: () -> Hash[String, Array[untyped]]
        def empty_namespaces: () -> Array[untyped]
        def regular_nodes: () -> Array[untyped]
        def namespaces?: () -> bool
      end

      interface _NamespaceCollectionSpec
        def namespace_nodes: (_FormatterResult parser_result) -> Array[_Node]
        def pick_namespace_for_class: (_Node class_node, Array[_Node] namespace_nodes) -> _Node?
        def empty_namespaces: (_FormatterResult parser_result, Array[_Node] namespace_nodes, Hash[String, Array[_Node]] namespaces_with_classes) -> Array[_Node]
        def regular_nodes: (_FormatterResult parser_result) -> Array[_Node]
      end
      
      interface _DiagramDetail
        def format: (_FormatterResult parser_result) -> String
        def syntax: (?_FormatterResult?) -> _Syntax
        def entity_builder: (_FormatterResult parser_result, _NamespaceCollection namespace_collection) -> Hash[Symbol, Array[untyped]]
        def namespace_collection: (_FormatterResult parser_result) -> _NamespaceCollection
        def trailing_newline?: () -> bool
      end
      
      interface _Syntax
        def header: () -> (String | Array[String])
        def footer: () -> (String | nil)
        def class_definition: (String, Array[String]) -> Array[String]
        def module_definition: (String, Array[String]) -> Array[String]
        def namespace_definition: (String, Array[String]) -> Array[String]
        def empty_namespace_definition: (String) -> Array[String]
        def note_for_namespace: (String, String) -> String
        def inheritance_arrow: (String, String, ?String?) -> String
        def delegation_arrow: (String, String, ?String?) -> String
        def comment: (String) -> String
        def method_signatures: (Array[untyped]) -> Array[String]
        def method_signature: (visibility: String, static: bool, name: String, params: Array[String], block: String, return_type: String) -> String
        def build_relationships: (Array[untyped]) -> Array[String]
      end
    end
  end
end



module Formatter
  def self.format: (_FormatterResult parser_result, ?format_type: Symbol) -> String
  def format: (_FormatterResult parser_result, ?format_type: Symbol) -> String

  class Diagram
    @factory: untyped
    @trailing_newline: bool
    @parser_result: _FormatterResult

    def initialize: (Symbol factory_key) -> void
    def format: (_FormatterResult parser_result) -> String

    private

    attr_reader factory: untyped
    attr_reader trailing_newline: bool
    attr_reader parser_result: _FormatterResult

    def prepare_diagram_context: (_FormatterResult parser_result) -> Hash[Symbol, untyped]
    def merge_entities_in_order: (Hash[Symbol, Array[untyped]] entity_hash) -> Array[untyped]
    def namespaces?: (Array[untyped] entities, Array[Symbol] namespace_entity_types) -> bool

    class OutputBuilder
      def self.execute: (Hash[Symbol, untyped]) -> Array[String]
      
      @diagram_context: Hash[Symbol, untyped]
      @output: Array[String]
      
      def initialize: (Hash[Symbol, untyped] diagram_context) -> void
      def execute: () -> Array[String]

      private
      
      attr_reader diagram_context: Hash[Symbol, untyped]
      attr_reader output: Array[String]

      def self.build_class_diagrams_and_notes: (Array[untyped] entities, untyped syntax, Array[Symbol] namespace_entity_types) -> Hash[Symbol, Array[String]]
      def self.build_relationships: (_FormatterResult parser_result, untyped syntax) -> Array[String]
      
      def add_header_to_output: () -> void
      def add_footer_to_output: () -> void
      def add_diagrams_to_output: () -> void
      def add_notes_to_output: () -> void
      def add_relationships_to_output: () -> void
      def build_header: (untyped syntax) -> Array[String]
      def build_footer: (untyped syntax) -> Array[String]
      def build_diagrams: (Hash[Symbol, untyped] diagram_context, untyped syntax) -> Array[String]
      def build_notes: (Array[untyped] entities) -> Array[String]
      def build_relationships: (_FormatterResult parser_result, untyped syntax) -> Array[String]
      def compact_blank_lines: () -> Array[String]
      def filter_blank_lines_with_namespace_rule?: (Integer index) -> bool

      class ClassDiagramsBuilder
        def self.execute: (Array[untyped] entities, untyped syntax, Array[Symbol]? namespace_entity_types) -> Array[String]

        def initialize: (Array[untyped] entities, untyped syntax, Array[Symbol]? namespace_entity_types) -> void
        def execute: () -> Array[String]

        private
        def build_entity_diagram_parts: (entity: untyped, has_namespaces: bool, non_empty_entities: Array[untyped], index: Integer) -> Array[String]
        def namespace_exists?: (Array[untyped] entities, Array[Symbol] namespace_entity_types) -> bool
        def build_rendered_diagrams: (untyped entity, untyped syntax, bool has_namespaces, Array[Symbol] namespace_entity_types) -> Array[String]
        def separator_required?: (untyped current_entity, untyped next_entity) -> bool

        @entities: Array[untyped]
        @syntax: untyped
        @namespace_entity_types: Array[Symbol]?

        attr_reader entities: Array[untyped]
        attr_reader syntax: untyped
        attr_reader namespace_entity_types: Array[Symbol]?
      end
    end
    
    class NamespaceCollection
      @parser_result: _FormatterResult
      @spec: untyped
      @namespace_nodes: Array[_Node]
      @all_classes: Array[_Node]
      
      def initialize: (_FormatterResult parser_result, spec: untyped) -> void
      def namespaces?: () -> bool
      def collect_namespaces_with_classes: () -> Hash[String, Array[_Node]]
      def empty_namespaces: () -> Array[_Node]
      def regular_nodes: () -> Array[_Node]
      def each: () { (_Node) -> void } -> void
      def any?: () { (_Node) -> bool } -> bool
      
      private
      
      attr_reader parser_result: _FormatterResult
      attr_reader spec: untyped
      attr_reader namespace_nodes: Array[_Node]
      attr_reader all_classes: Array[_Node]
    end
  end

  class Json
    def self.format: (_FormatterResult parser_result) -> String

    class Parameter
      @type: untyped
      @name: untyped
      @superclass: untyped
      @methods: untyped
      @includes: untyped
      @extends: untyped
      @inner_classes: untyped
      @is_namespace: untyped
      @parameters: untyped
      @return_type: untyped
      @method_type: untyped
      @visibility: untyped
      @overloads: untyped
      @block: untyped

      def initialize: (
        ?type: untyped,
        ?name: untyped,
        ?superclass: untyped,
        ?methods: untyped,
        ?includes: untyped,
        ?extends: untyped,
        ?inner_classes: untyped,
        ?is_namespace: untyped,
        ?parameters: untyped,
        ?return_type: untyped,
        ?method_type: untyped,
        ?visibility: untyped,
        ?overloads: untyped,
        ?block: untyped
      ) -> void

      attr_reader type: untyped
      attr_reader name: untyped
      attr_reader superclass: untyped
      attr_reader methods: untyped
      attr_reader includes: untyped
      attr_reader extends: untyped
      attr_reader inner_classes: untyped
      attr_reader is_namespace: untyped
      attr_reader parameters: untyped
      attr_reader return_type: untyped
      attr_reader method_type: untyped
      attr_reader visibility: untyped
      attr_reader overloads: untyped
      attr_reader block: untyped
    end

    private

    def self.build_structure: (_FormatterResult parser_result) -> Array[Hash[Symbol, untyped]]
    def self.filter_nodes_for_json: (Array[_Node] nodes) -> Array[_Node]
    def self.convert_class_definition: (_ClassNode class_def) -> Formatter::Json::Definition::Class
    def self.convert_module_definition: (_Node module_def) -> Formatter::Json::Definition::Module
    def self.convert_method: (_FormatterResultMethod method) -> Formatter::Json::Definition::Method
    def self.convert_block: (Result::NodeEntity::Block block) -> Hash[Symbol, untyped]
    def self.convert_parameters_to_definitions: (Array[Parameter | Hash[Symbol, String]] parameters) -> Array[{ kind: String, name: String, type: String }]
    def self.convert_inner_class: (Hash[Symbol, untyped] inner_class) -> Formatter::Json::Definition::InnerClass
    def self.convert_method_hash: (Hash[Symbol, untyped] method_hash) -> Formatter::Json::Definition::Method
    def self.convert_block_hash: (Hash[Symbol, untyped] block_hash) -> Hash[Symbol, untyped]


    module Definition
      class Base
        def to_hash: () -> Hash[Symbol, untyped]

        private

        def should_output_to_json?: (Symbol key, untyped value) -> bool
        def convert_value_for_hash: (untyped value) -> untyped
      end

      class Class < Base
        @parameter: Formatter::Json::Parameter
        @type: (String | Symbol)
        @name: String
        @superclass: String?
        @methods: Array[Formatter::Json::Definition::Method]
        @includes: Array[String]
        @extends: Array[String]
        @inner_classes: Array[Formatter::Json::Definition::InnerClass]?

        def initialize: (Formatter::Json::Parameter parameter) -> void

        private

        def should_output_to_json?: (Symbol key, untyped value) -> bool
        def self.build: (untyped class_def) -> Class
      end

      class Module < Base
        @parameter: Formatter::Json::Parameter
        @type: (String | Symbol)
        @name: String
        @superclass: nil
        @methods: Array[Formatter::Json::Definition::Method]
        @includes: Array[String]
        @extends: Array[String]
        @is_namespace: bool?

        def initialize: (Formatter::Json::Parameter parameter) -> void

        private

        def should_output_to_json?: (Symbol key, untyped value) -> bool
        def self.build: (untyped module_def) -> Module
      end

      class Method < Base
        @parameter: Formatter::Json::Parameter
        @name: String
        @method_type: String?
        @visibility: String?
        @parameters: Array[{ kind: String, name: String, type: String }]
        @return_type: String?
        @overloads: untyped
        @block: Hash[Symbol, untyped]?

        def initialize: (Formatter::Json::Parameter parameter) -> void
        def to_hash: (?simple: bool) -> Hash[Symbol, untyped]
        attr_reader name: String
        attr_reader parameters: Array[{ kind: String, name: String, type: String }]
        attr_reader return_type: String?
        def self.build: (untyped method) -> Method
        def self.build_from_hash: (Hash[Symbol, untyped] method_hash) -> Method
        def self.convert_parameters_to_definitions: (untyped parameters) -> untyped
        def self.convert_block: (untyped block) -> untyped
        def self.convert_block_hash: (untyped block_hash) -> untyped
      end

      class InnerClass < Base
        @parameter: Formatter::Json::Parameter
        @name: String
        @type: String
        @methods: Array[Formatter::Json::Definition::Method]

        def initialize: (Formatter::Json::Parameter parameter) -> void
        def to_hash: () -> Hash[Symbol, untyped]
        attr_reader name: String
        attr_reader type: String
        attr_reader methods: Array[Formatter::Json::Definition::Method]
        def self.build: (untyped inner_class) -> InnerClass
      end
    end
  end
end